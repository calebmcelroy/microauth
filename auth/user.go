package auth

import (
	"github.com/google/uuid"
	"github.com/pkg/errors"
	"regexp"
)

// User is the entity for passing user
type User struct {
	// UUID is unique and cannot be changed. UUID is generated by UserCreate
	UUID string

	// Email is unique and can be changed by user.
	Email string

	// Username is unique and can be changed by user.
	Username string

	// Roles is a unique slice of role slugs
	Roles []string

	PasswordHash string

	// Version is used for optimistic locking by UserRepo.Update(User).
	Version uint
}

// UserCreate creates a user.
type UserCreate struct {
	UsernameValidator Validator
	PasswordValidator Validator

	// RoleConfigs is used to verify authorization to create
	RoleConfigs       []RoleConfig
	TokenAuthenticate TokenAuthenticate
	UserRepo          UserRepo
	PasswordHasher    Hasher
}

// Execute params user.Username, user.Email, user.Roles, & password are required. user.UUID is generated.
// The authToken param is optional, although configuration within RoleConfigs may require authorization
// for the role being created. See RoleConfig.
// UsernameValidator & PasswordValidator validate if the username/password are conform to requirements.
func (u UserCreate) Execute(user User, password string, authToken string) (ID string, error error) {

	badRequest := user.Username == "" ||
		user.Email == "" ||
		password == "" ||
		len(user.Roles) == 0

	if badRequest {
		return "", newBadRequestError("username, email, password, and role are required")
	}

	if !validateEmail(user.Email) {
		return "", newBadRequestError("email invalid")
	}

	err := u.UsernameValidator.Validate(user.Username)
	if err != nil {
		return "", newBadRequestError(err.Error())
	}

	err = u.PasswordValidator.Validate(password)
	if err != nil {
		return "", newBadRequestError(err.Error())
	}

	if authToken != "" {
		authUserID, err := u.TokenAuthenticate.Execute(authToken)
		if err != nil {
			return "", err
		}

		authUser, err := u.UserRepo.Get(authUserID)
		if err != nil {
			return "", err
		}

		if !canAuthUserCreateUser(u.RoleConfigs, user, authUser) {
			return "", newAuthorizationError("cannot create user with role")
		}
	} else {
		for _, r := range user.Roles {
			rc := getRoleConfig(u.RoleConfigs, r)

			if !rc.Open {
				return "", newAuthorizationError("cannot create user with role '" + r + "'")
			}
		}
	}

	user.UUID = uuid.New().String()
	err = u.UserRepo.Insert(user)

	if err != nil {
		return "", errors.Wrap(err, "failed inserting user into db")
	}

	return user.UUID, nil
}

func canAuthUserCreateUser(rcs []RoleConfig, newUser User, authUser User) bool {
	if len(rcs) == 0 {
		return false
	}

	for _, r := range rcs {
		if !r.CanCreateUser(newUser, authUser) {
			return false
		}
	}

	return true
}

// UserAuthenticate validates a user's credentials
type UserAuthenticate struct {
	UserRepo       UserRepo
	PasswordHasher Hasher
}

// Execute returns nil error on success. An error implementing Authentication() is returned when invalid.
// An error implementing BadRequest() is return when username or password are empty.
func (a UserAuthenticate) Execute(username string, password string) (userID string, error error) {
	if username == "" || password == "" {
		return "", newBadRequestError("username and password are required")
	}

	u, err := a.UserRepo.GetByUsername(username)

	if err != nil {
		return "", errors.Wrap(err, "failed getting user")
	}

	passMatch := u.PasswordHash == a.PasswordHasher.Hash(password)

	if u.PasswordHash == "" || !passMatch {
		return "", newAuthenticationError("invalid username or password")
	}

	return u.UUID, nil
}

// UserExists checks if user exists
type UserExists struct {
	UserRepo UserRepo
}

// Execute returns true on success. Username is required.
func (usecase *UserExists) Execute(username string) (bool, error) {
	if username == "" {
		return false, newBadRequestError("username is required")
	}

	user, err := usecase.UserRepo.GetByUsername(username)

	if err != nil {
		return false, errors.Wrap(err, "failed searching for user")
	}

	if user.Username != username {
		return false, nil
	}

	return true, nil
}

// UserInfo gets a users info
type UserInfo struct {
	UserRepo          UserRepo
	TokenAuthenticate TokenAuthenticate
	RoleConfigs       []RoleConfig
}

// Execute returns a User struct and nil error on success. The authToken parameter is required.
// RoleConfigs is used to determine authorization to read user info.
func (usecase *UserInfo) Execute(username string, authToken string) (User, error) {
	getUsers := getUserAndAuthUser{
		UserRepo:          usecase.UserRepo,
		TokenAuthenticate: usecase.TokenAuthenticate,
		RoleConfigs:       usecase.RoleConfigs,
	}

	u, authUser, err := getUsers.Execute(username, authToken)

	if err != nil {
		return User{}, err
	}

	canGetInfo := false

	for _, role := range authUser.Roles {
		rc := getRoleConfig(usecase.RoleConfigs, role)
		if rc.CanGetOtherUserInfo(u, authUser) {
			canGetInfo = true
			break
		}
	}

	if !canGetInfo {
		return User{}, newAuthorizationError("unauthorized to get user info")
	}

	u.PasswordHash = ""
	return u, nil
}

// UserAssignRole assigns a new role to a user
type UserAssignRole struct {
	UserRepo          UserRepo
	TokenAuthenticate TokenAuthenticate
	RoleConfigs       []RoleConfig
}

// Execute returns a nil error on success. Parameters username, roleSlug, & authToken are required.
// Returns error implementing Authorization() when roleSlug's RoleConfig CanAssignUserRole func returns false.
// Returns error implementing BadRequest() when user already has role.
func (usecase *UserAssignRole) Execute(username string, roleSlug string, authToken string) error {
	getUsers := getUserAndAuthUser{
		UserRepo:          usecase.UserRepo,
		TokenAuthenticate: usecase.TokenAuthenticate,
		RoleConfigs:       usecase.RoleConfigs,
	}

	u, authUser, err := getUsers.Execute(username, authToken)

	if err != nil {
		return err
	}

	rc := getRoleConfig(usecase.RoleConfigs, roleSlug)
	if !rc.CanAssignUserRole(u, authUser) {
		return newAuthorizationError("unauthorized to assign role")
	}

	newRoleExists := false
	for _, r := range u.Roles {
		if r == roleSlug {
			newRoleExists = true
		}
	}

	if newRoleExists {
		return newBadRequestError("role already exists")
	}

	u.Roles = append(u.Roles, roleSlug)
	err = usecase.UserRepo.Update(u)
	if err != nil {
		return errors.Wrap(err, "failed updating user")
	}

	return nil
}

// UserRemoveRole removes role from a user
type UserRemoveRole struct {
	UserRepo          UserRepo
	TokenAuthenticate TokenAuthenticate
	RoleConfigs       []RoleConfig
}

// Execute returns a nil error on success. Parameters username, roleSlug, & authToken are required.
// Returns error implementing Authorization() when roleSlug's RoleConfig CanRemoveUserRole func returns false.
// Returns error implementing BadRequest() when user doesn't have role.
func (usecase *UserRemoveRole) Execute(username string, roleSlug string, authToken string) error {
	getUsers := getUserAndAuthUser{
		UserRepo:          usecase.UserRepo,
		TokenAuthenticate: usecase.TokenAuthenticate,
		RoleConfigs:       usecase.RoleConfigs,
	}

	u, authUser, err := getUsers.Execute(username, authToken)

	if err != nil {
		return err
	}

	rc := getRoleConfig(usecase.RoleConfigs, roleSlug)
	if !rc.CanRemoveUserRole(u, authUser) {
		return newAuthorizationError("unauthorized to remove role")
	}

	i := -1
	for index, r := range u.Roles {
		if r == roleSlug {
			i = index
		}
	}

	if i == -1 {
		return newBadRequestError("user doesn't have role")
	}

	//removes index from slice
	u.Roles = append(u.Roles[:i], u.Roles[i+1:]...)

	err = usecase.UserRepo.Update(u)
	if err != nil {
		return errors.Wrap(err, "failed updating user")
	}

	return nil
}

type getUserAndAuthUser struct {
	UserRepo          UserRepo
	TokenAuthenticate TokenAuthenticate
	RoleConfigs       []RoleConfig
}

func (usecase *getUserAndAuthUser) Execute(username string, authToken string) (user User, authenticatedUser User, error error) {
	if username == "" {
		return User{}, User{}, newBadRequestError("username is required")
	}

	if authToken == "" {
		return User{}, User{}, newBadRequestError("authentication token is required")
	}

	authUserID, err := usecase.TokenAuthenticate.Execute(authToken)

	if err != nil {
		return User{}, User{}, err
	}

	u, err := usecase.UserRepo.GetByUsername(username)

	if err != nil {
		return User{}, User{}, errors.Wrap(err, "failed retrieving user")
	}

	if u.Username != username {
		return User{}, User{}, newAuthorizationError("unauthorized to get user info")
	}

	authUser, err := usecase.UserRepo.Get(authUserID)

	if err != nil {
		return User{}, User{}, errors.Wrap(err, "failed retrieving authenticated user")
	}

	return u, authUser, nil
}

// UserChangePassword changes a user's password
type UserChangePassword struct {
	UserRepo          UserRepo
	TokenAuthenticate TokenAuthenticate
	RoleConfigs       []RoleConfig
	PasswordValidator Validator
	PasswordHasher    Hasher
}

// Execute returns a nil error on success. Parameters username, newPassword, authToken, & authUserPassword are required.
// Returns error implementing Authorization() when auth failed or all the authenticated user's roles CanEditUserRole func return false.
// Returns error implementing BadRequest() when user doesn't exist.
func (usecase *UserChangePassword) Execute(username string, newPassword string, authToken string, authUserPassword string) error {
	if username == "" {
		return newBadRequestError("Username is required")
	}

	getUsers := getUserAndAuthUser{
		UserRepo:          usecase.UserRepo,
		TokenAuthenticate: usecase.TokenAuthenticate,
		RoleConfigs:       usecase.RoleConfigs,
	}

	u, authUser, err := getUsers.Execute(username, authToken)

	if err != nil {
		return err
	}

	if authUser.PasswordHash != usecase.PasswordHasher.Hash(authUserPassword) {
		return newAuthenticationError("invalid password")
	}

	canEdit := false

	if u.UUID == authUser.UUID {
		canEdit = true
	} else {
		for _, r := range authUser.Roles {
			c := getRoleConfig(usecase.RoleConfigs, r)
			if c.CanEditUser(u, authUser) {
				canEdit = true
				break
			}
		}
	}

	if !canEdit {
		return newAuthorizationError("cannot edit user")
	}

	err = usecase.PasswordValidator.Validate(newPassword)
	if err != nil {
		return errors.Wrap(err, "new password invalid")
	}

	u.PasswordHash = usecase.PasswordHasher.Hash(newPassword)
	return errors.Wrap(usecase.UserRepo.Update(u), "failed updating user")
}

// UserRepo is used for storage and retrieval of user data.
type UserRepo interface {
	Get(UUID string) (user User, err error)
	GetByUsername(username string) (user User, err error)

	// Insert is used to add a user.
	// Will return error that implements BadRequest() upon Email or Username exists conflict.
	Insert(User) (error error)

	// Update is used to update a user. Update increments the version on every update.
	// Will return error that implements BadRequest() upon Version conflict.
	Update(User) error
}

// RoleConfig is used to define a role, including it's name, slug, & capabilities
type RoleConfig struct {
	// Name is for displaying purposes
	Name string

	// Slug is used as the identifier for a role and must be unique
	Slug string

	// Open defines whether anyone can register without authentication or authorization
	Open bool

	// CanCreateUser is used to validate whether an authenticated user
	// is allowed to create a new user with this role
	CanCreateUser func(newUser User, u User) bool

	// CanAssignUserRole is used to validate whether an authenticated user
	// is allowed to assign this role to a particular user
	CanAssignUserRole func(targetUser User, u User) bool

	// CanRemoveUserRole is used to validate whether an authenticated user
	// is allowed to remove this role from a particular user
	CanRemoveUserRole func(targetUser User, u User) bool

	// CanEditUser validates whether an authenticated user is allowed to edit a particular user.
	// This validates for UserChangePassword, UserChangeUsername, & UserChangeEmail.
	CanEditUser func(targetUser User, u User) bool

	// CanGetOtherUserInfo is used to validate whether an authenticated user
	// is allowed to GetInfo from another user with this role
	// if the user has multiple roles this func is ran for each role
	// checking if any returns true
	CanGetOtherUserInfo func(targetUser User, u User) bool
}

// Hasher simple interface for Hash method
type Hasher interface {
	//Hash a string
	Hash(string) string
}

func getRoleConfig(rcs []RoleConfig, role string) RoleConfig {
	for _, r := range rcs {
		if r.Slug == role {
			return r
		}
	}

	return RoleConfig{}
}

var rxEmail = regexp.MustCompile("^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$")

func validateEmail(email string) bool {
	return rxEmail.MatchString(email)
}
